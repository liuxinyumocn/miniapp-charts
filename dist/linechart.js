/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/base.js":
/*!*********************!*\
  !*** ./src/base.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ChartBase; });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./src/util.js\");\n\n\n\n/**\n * 图表组件基础类，封装一些canvas画图的基本方法\n * 这里可用于兼容H5和小程序\n * 因为小程序和H5的绘图API并不是完全一致的，通过基础类来兼容是最合适的\n */\nclass ChartBase {\n    constructor() {\n    }\n\n    wordWidth(words, fontSize) {\n        if ( words === undefined || words === null )\n            return 0;\n\n        let totLength = 0;\n\n        for ( let i = 0; i < words.length; i++ ) {\n            let strCode = words.charCodeAt(i);\n\n            if ( strCode > 128 )\n                totLength += fontSize;\n\n            else\n                totLength += fontSize / 2;\n        }\n\n        return totLength;\n    }\n\n    getWordWidth(word) {\n        if ( typeof(word.text) === 'number' )\n            word.text = word.text.toString();\n\n        let w = this.wordWidth(word.text, word.fontSize);\n\n        return Math.ceil(w);\n    }\n\n    /**\n     * 根据给定样式绘制文字\n     */\n    drawWord(ctx, word) {\n        if ( typeof(word.text) === 'number' )\n            word.text = word.text.toString();\n\n        ctx.beginPath();\n\n        //ctx.setTextBaseline('normal')\n        ctx.setFontSize(word.fontSize);\n        ctx.setFillStyle(word.color);\n        ctx.setTextAlign(word.textAlign || 'left');\n        ctx.fillText(word.text, word.x, word.y);\n\n        ctx.stroke();\n        ctx.closePath();\n    }\n\n    /**\n     * 绘制一个矩形\n     */\n    drawRect(ctx, rect) {\n        ctx.beginPath();\n        ctx.setStrokeStyle(rect.fillColor);\n        ctx.setFillStyle(rect.fillColor);\n        ctx.fillRect(rect.x, rect.y, rect.width, rect.height);\n        ctx.closePath();\n    }\n\n    /**\n     * 根据给定样式绘制线条\n     */\n    drawLine(ctx, line) {\n        ctx.beginPath();\n        ctx.setLineWidth(line.width || 1);\n        ctx.setStrokeStyle(line.color);\n\n        ctx.moveTo(line.start.x, line.start.y);\n        ctx.lineTo(line.end.x, line.end.y);\n\n        ctx.stroke();\n        ctx.closePath();\n    }\n\n    /**\n     * 绘制一条由线段连接在一起的长线\n     * 绘制多个线条时，效率更高的做法是，创建一个包含所有线条的路径，\n     * 然后通过单个绘制调用进行绘制。也就是说，无需分别绘制各个线条。\n     * 当这条线由很多线段组成的时候，可以非常显著提升性能!\n     */\n    drawLongLineWithFill(ctx, points, opts = {\n        lineWidth: 1,\n        lineColor: '#7587db',\n        fillColor: 'rgba(117, 135, 219, 0.3)',\n    }) {\n        ctx.beginPath();\n        ctx.setFillStyle(opts.fillColor);\n        ctx.setLineWidth(opts.lineWidth);\n        ctx.setStrokeStyle(opts.lineColor);\n\n        let start = points[0];\n        let end   = points[points.length - 1];\n\n        ctx.moveTo(start.x, start.y);\n\n        for ( let index = 1; index < points.length - 1; index++ ) {\n            let point = points[index];\n            if ( index === 1 )\n                ctx.moveTo(point.x, point.y);\n\n            else\n                ctx.lineTo(point.x, point.y);\n        };\n\n        ctx.stroke();\n\n        ctx.lineTo(end.x, end.y);\n        ctx.lineTo(start.x, start.y);\n\n        ctx.fill()\n\n        ctx.closePath();\n    }\n\n    /**\n     * 根据给定样式绘制一个圆\n     */\n    drawCircle(ctx, circle) {\n        ctx.beginPath();\n\n        ctx.setStrokeStyle(circle.strokeColor);\n        ctx.setFillStyle(circle.fillColor);\n        ctx.setLineWidth(circle.lineWidth || 1);\n        ctx.arc(circle.x, circle.y, circle.r, 0, 2 * Math.PI);\n\n        ctx.stroke();\n        ctx.fill();\n        ctx.closePath();\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/base.js?");

/***/ }),

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    debug: false,\n\n    /**\n     * 默认的图表宽度\n     */\n    width : 414,\n\n    /**\n     * 默认的图表高度\n     */\n    height: 200,\n\n    /**\n     * 图表内本身的padding\n     */\n    padding: {\n        left  : 10,\n        right : 10,\n        top   : 10,\n        bottom: 5\n    },\n\n    // 折线图默认配置\n    lineStyle: {\n        lineWidth : 1,\n        lineColor : '#7587db',\n        fillColor : 'rgba(117, 135, 219, 0.3)',\n        // 是否需要背景颜色\n        needFill  : true,\n        circle    : {\n            show       : true,\n            fillColor  : '#FFFFFF',\n            strokeColor: '#FFAA00',\n            radius     : 1.2,\n        }\n    },\n\n    /**\n     * 在数据点很多的时候，如果每个点都要画个圆圈会大大影响性能\n     * 同时圆圈过于多也会影响美观，因此设定阀值，大于此阀值的情况不绘制圆圈\n     */\n    maxCircleCount: 30,\n\n    /**\n     * 默认x轴打七个点\n     * 可以自行配置，但仍然会有保底逻辑\n     */\n    xAxisCount   : 7,\n\n    // x轴文案的样式配置\n    xAxis: {\n        show     : true,\n        marginTop: 10,\n        color    : '#B8B8B8',\n        fontSize : 11,\n    },\n\n    /**\n     * X轴轴体的样式配置\n     */\n    xAxisLine: {\n        show      : false,\n        centerShow: true,\n        width     : 0.6,\n        color     : '#C6C6C6',\n        style     : 'solid',\n    },\n\n    /**\n     * 默认Y轴打四个点\n     * 也可以自行配置，但仍然会有保底逻辑\n     */\n    yAxisCount  : 4,\n\n    /**\n     * y轴的样式配置\n     */\n    yAxis: {\n        show       : true,\n        marginLeft : 0,\n        marginRight: 10,\n        color      : '#B8B8B8',\n        fontSize   : 11,\n    },\n\n    /**\n     * Y轴轴体的样式\n     */\n    yAxisLine : {\n        show      : true,\n        centerShow: false,\n        width     : 0.2,\n        color     : '#C6C6C6',\n    },\n\n    toolTip: {\n        lineColor  : '#C6C6C6',\n        lineWidth  : 0.5,\n        fontSize   : 11,\n        color      : '#FFFFFF',\n        fillColor  : 'rgba(136, 136, 136, 0.6)',\n        //needCircle : true,\n        linePadding: 5,\n\n        padding: {\n            left  : 5,\n            right : 5,\n            top   : 5,\n            bottom: 5,\n        },\n    }\n});\n\n\n\n//# sourceURL=webpack:///./src/config.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return LineChart; });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./src/util.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config.js */ \"./src/config.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base.js */ \"./src/base.js\");\n/**\n * @author: zimyuan\n * @lase-edit-date: 2018-05-18\n */\n\n\n\n\n\n\n/**\n * 小程序折线图绘制组件\n */\nclass LineChart extends _base_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n    /**\n     * @param { CanvasContext } ctx1: 小程序的绘图上下文\n     * @param { CanvasContext } ctx2: 小程序的绘图上下文\n     * @param { Object } cfg: 组件配置\n     */\n    constructor(ctx1, cfg = {}, ctx2) {\n        super();\n\n        this.ctx1 = ctx1;\n\n        // 用于绘制tooltip以提高性能，如果没有，则在ctx1上绘制\n        this.ctx2 = ctx2 || ctx1;\n\n        /**\n         * 约定！所有的内部变量都需要这里先声明\n         * 可以大大提高源码阅读性\n         */\n\n        // 用于性能数据打点\n        this._start       = 0;\n\n        // 为了方便调试，在调试模式下会打出性能信息\n        this._performance = {};\n\n        // 本实例配置文件\n        this._config      = this.getConfig(cfg);\n\n        // 实际绘图区域边界点信息\n        this._boundary    = {};\n\n        // 线条数据\n        this._datasets    = [];\n\n        // 寄存最终用于渲染的数据\n        this._render      = {};\n\n        // 用于触摸事件的函数节流\n        this._touchTimer  = 0;\n    }\n\n    /**\n     * 性能数据打点\n     */\n    log(performancePointName) {\n        this._performance[performancePointName] = new Date() - this._start;\n    }\n\n    /**\n     * 获取本实例的配置\n     */\n    getConfig(cfg) {\n        if ( !Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[\"isPlainObject\"])(cfg) )\n            throw new Error('options must be type of Object');\n\n        // 所有的实例先深拷贝一份默认配置文件，避免不同实例之间的配置相互影响\n        let copyConfig = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[\"deepCopy\"])(_config_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n        for ( let key in copyConfig ) {\n            if ( cfg[key] !== undefined ) {\n                if ( typeof copyConfig[key] !== typeof cfg[key] )\n                    throw new Error(`[LineChart] TypeMismatch：${key} must be type of ${ typeof copyConfig[key]}`);\n\n                // Object类型的extend而不是直接覆盖\n                if ( Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[\"isPlainObject\"])(cfg[key]) )\n                    copyConfig[key] = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])(copyConfig[key], cfg[key]);\n\n                else\n                    copyConfig[key] = cfg[key];\n            }\n        }\n\n        return copyConfig;\n    }\n\n    /**\n     * 因为可以设置padding样式，所以需要维护真实的边界点\n     * 才可以实现精确绘制\n     */\n    calBoundaryPoint() {\n        let _config = this._config;\n        let padding = this._config.padding;\n\n        // 实际绘图区域的左上角\n        this._boundary.leftTop = {\n            x: padding.left,\n            y: padding.top\n        };\n\n        // 计算实际绘图区域的左下角信息\n        this._boundary.leftBottom = {\n            x: padding.left,\n            y: (   _config.height\n                - padding.bottom\n                - _config.xAxis.fontSize\n                - _config.xAxis.marginTop  )\n        };\n\n        // 计算实际绘图区域的右上角信息\n        this._boundary.rightTop=  {\n            x: _config.width - padding.right,\n            y: padding.top\n        };\n\n        this._boundary.rightBottom = {\n            x: _config.width - padding.right,\n            y: this._boundary.leftBottom.y\n        };\n\n        this._boundary.size = {\n            width : this._boundary.rightTop.x - this._boundary.leftTop.x,\n            height: this._boundary.leftBottom.y - this._boundary.leftTop.y,\n        };\n\n        this.log('calBoundaryPoint');\n\n        return this._boundary;\n    }\n\n    // 计算用于绘制的点的信息\n    calPointData() {\n        let pointData      = [];\n        let yAxisWidth     = this._render.yAxisWidth;\n        let leftBottom     = this._boundary.leftBottom;\n        let startX         = leftBottom.x + yAxisWidth;\n        let longestLine    = this._render.longestLine;\n\n        // 为了提高性能，会限制单条线最多圆的数量\n        let needCircle     = (  this._config.maxCircleCount >= longestLine.points.length\n                              ? true\n                              : false  );\n        // 原点\n        let origin     = {\n            x: leftBottom.x + yAxisWidth,\n            y: leftBottom.y,\n        };\n        let circlePoints = []\n\n        this._datasets.forEach((oneline ) => {\n            let style  = oneline.style;\n            let cStyle = style.circle;\n\n            let points   = oneline.points;\n            let length   = points.length;\n            let _oneline = {\n                points     : [],\n                style\n            };\n\n            points.forEach((item, index) => {\n                if ( index < length ) {\n                    let temp = {\n                        x: startX + index * this._render.unitX,\n                        y: leftBottom.y - ( item.y - this._render.min) * this._render.unitY * this._render.yMultiple,\n                    };\n\n                    if ( style.circle && style.circle.show && needCircle ) {\n                        let circle = {\n                            x          : temp.x,\n                            y          : temp.y,\n                            st         : 0,\n                            ed         : 2 * Math.PI,\n                            r          : cStyle.radius      || 2,\n                            fillColor  : cStyle.fillColor   || '#FFFFFF',\n                            strokeColor: style.lineColor,\n                            lineWidth  : style.lineWidth,\n                        };\n                        circlePoints.push(circle);\n                    }\n\n                    _oneline.points.push(temp);\n                }\n            });\n\n            // 为了能够实现闭合，增加的辅助点\n            _oneline.points.unshift(origin);\n            _oneline.points.push({\n                x           : _oneline.points[_oneline.points.length - 1].x,\n                y           : leftBottom.y,\n            });\n\n            pointData.push(_oneline);\n        });\n\n        this._render.circlePoints = circlePoints;\n        this._render.pointData    = pointData;\n    }\n\n    calXAxisLines() {\n        let yAxisWidth  = this._render.yAxisWidth;\n        let leftBottom  = this._boundary.leftBottom;\n        let rightBottom = this._boundary.rightBottom;\n        let xAxisLine   = this._config.xAxisLine;\n\n        // 计算X轴中轴线数据\n        this._render.xCenterAxis = {\n            start: {\n                x: leftBottom.x + yAxisWidth,\n                y: leftBottom.y\n            },\n            end  : {\n                x: rightBottom.x,\n                y: leftBottom.y\n            },\n            width: xAxisLine.width,\n            color: xAxisLine.color,\n        }\n    }\n\n    /**\n     * 计算用于X轴绘制需要的数据\n     */\n    calXAxis() {\n        let datasets    = this._datasets;\n        let data        = this._render;\n\n        let length      = this._render.longestLinePointCnt;\n        let maxXPoint   = this._config.xAxisCount;\n        let points      = this._render.longestLine.points;\n        let xAxis       = this._config.xAxis;\n\n        let leftBottom  = this._boundary.leftBottom;\n        let rightBottom = this._boundary.rightBottom;\n\n        let xAxisData   = [];\n\n        // 计算X轴两个点之间的像素距离\n        data.unitX = ( rightBottom.x - leftBottom.x - this._render.yAxisWidth ) / (points.length - 1 );\n\n        let xDivider  = parseInt(length / ( maxXPoint) );\n        if ( xDivider === 0 )\n            xDivider = 1;\n\n        let leftStart = this._render.yAxisWidth + leftBottom.x;\n        let bottom    = leftBottom.y + xAxis.marginTop + xAxis.fontSize;\n\n        for ( let i = 0; i < length; i += xDivider ) {\n            let word = {\n                text    : points[i].x,\n                color   : xAxis.color,\n                fontSize: xAxis.fontSize,\n                x       : leftStart + i * data.unitX,\n                y       : bottom\n            }\n\n            let width = this.getWordWidth(word);\n            word.x -= width / 2;\n\n            // 防止超边界\n            if ( word.x + width > this._config.width )\n                word.x = this._config.width - width - 1;\n\n            xAxisData.push(word);\n        }\n\n        this._render.xAxisData = xAxisData;\n    }\n\n    calYAxisLines() {\n        let data       = this._render;\n        let yAxisWidth = data.yAxisWidth;\n        let leftTop    = this._boundary.leftTop;\n        let leftBottom = this._boundary.leftBottom;\n        let rightTop   = this._boundary.rightBottom;\n        let yAxisLine  = this._config.yAxisLine;\n\n        // 计算Y轴中轴线数据\n        this._render.yCenterAxis = {\n            start: {\n                x: leftTop.x + yAxisWidth,\n                y: leftTop.y\n            },\n            end  : {\n                x: leftTop.x + yAxisWidth,\n                y: leftBottom.y\n            },\n            width: yAxisLine.width,\n            color: yAxisLine.color,\n        }\n\n        this._render.yAxisLines = [];\n        this._render.yAxisData.forEach((item, index) => {\n            if ( index > 0 ) {\n                this._render.yAxisLines.push({\n                    start: {\n                        x: item.x + yAxisWidth,\n                        y: item.y\n                    },\n                    end: {\n                        x: rightTop.x,\n                        y: item.y\n                    },\n                    width: yAxisLine.width,\n                    color: yAxisLine.color,\n                });\n            }\n        });\n    }\n\n    /**\n     * 计算Y轴的边界和阶梯值\n     */\n    calYAxis() {\n        let { max, min, yDivider, maxYPoint, longestLine } = this.calYAxisBoundary();\n\n        let yAxis      = this._config.yAxis;\n        let yAxisLine  = this._config.yAxisLine;\n\n        // 用于绘制的数据\n        let yAxisData  = [];\n\n        // Y轴文案所占据的宽度\n        let yAxisWidth = 0;\n\n        // 计算Y轴上两个点之间的像素值\n        let unitY = (  (  this._boundary.leftBottom.y\n                        - this._boundary.leftTop.y  )\n                     / ( yDivider * this._render.yMultiple  * this._config.yAxisCount + 1 )\n                    );\n\n        let leftStart   = this._boundary.leftTop.x + yAxis.marginLeft;\n        let bottomStart = this._boundary.leftBottom.y\n\n        for( let i = 0; i < this._config.yAxisCount + 1; i++ ) {\n            let word = {\n                text    : Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[\"changeUnit\"])(min + i * yDivider),\n                color   : yAxis.color,\n                fontSize: yAxis.fontSize,\n                x       : leftStart,\n                y       : bottomStart - ( i * yDivider * unitY * this._render.yMultiple )\n            };\n\n            yAxisWidth = Math.max(this.getWordWidth(word), yAxisWidth);\n\n            yAxisData.push(word);\n        }\n\n        // 考虑Y轴不需要文案的情况\n        yAxisWidth = ( yAxis.show\n                     ? yAxisWidth + yAxis.marginRight\n                     : 0  );\n\n\n        this._render.unitY               = unitY;\n        this._render.yAxisWidth          = yAxisWidth;\n        this._render.yAxisData           = yAxisData;\n        this._render.longestLinePointCnt = maxYPoint;\n        this._render.longestLine         = longestLine;\n\n        this.log('calYAxis');\n    }\n\n    getMinY(data) {\n        return data.reduce(\n            (min, p) => (  p.y < min\n                         ? p.y\n                         : min  ),\n            data[0].y\n        );\n    }\n\n    getMaxY(data) {\n        return data.reduce(\n            (max, p) => (  p.y > max\n                         ? p.y\n                         : max  ),\n            data[0].y\n        );\n    }\n\n    /**\n     * 计算用于Y轴绘制需要的数据\n     * https://codeburst.io/javascript-finding-minimum-and-maximum-values-in-an-array-of-objects-329c5c7e22a2\n     */\n    calYAxisBoundary() {\n        let datasets    = this._datasets;\n        let maxYPoint   = 0;\n        let longestLine = datasets[0];\n        let yAxisCount  = this._config.yAxisCount;\n        let max         = -Infinity;\n        let min         = Infinity;\n\n        let start = new Date();\n        datasets.forEach((oneline) => {\n            let points = oneline.points || [];\n\n            if ( points.length > maxYPoint ) {\n                maxYPoint   = points.length;\n                longestLine = oneline;\n            }\n\n            max = Math.max(this.getMaxY(points), max);\n            min = Math.min(this.getMinY(points), min);\n        });\n\n        let range = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[\"getDataRangeAndStep\"])(max, min, yAxisCount);\n\n        this._render.min       = range.min;\n        this._render.yMultiple = range.multiple;\n\n        return {\n            max     : range.max,\n            min     : range.min,\n            yDivider: range.divider,\n            maxYPoint,\n            longestLine\n        };\n    }\n\n    /**\n     * 计算tooltip当前点数据和标尺线数据\n     */\n    calToolTipPointData(e) {\n        let touchesx = e.touches[0].x;\n\n        let leftTop    = this._boundary.leftTop;\n        let rightTop   = this._boundary.rightTop;\n        let leftBottom = this._boundary.leftBottom;\n\n        let longestLine = this._render.longestLine;\n\n        let yAxisWidth = this._render.yAxisWidth;\n        let leftDis    = touchesx - ( leftTop.x + yAxisWidth );\n\n        // 边界值场景\n        if ( leftDis < 0 )\n            leftDis = 0;\n\n        else if ( leftDis > rightTop.x )\n            leftDis = rightTop.x;\n\n        // 取出当前手指对应的点索引\n        let pindex = Math.round(leftDis / this._render.unitX );\n\n        if ( pindex > longestLine.points.length - 1 )\n            pindex = longestLine.points.length - 1;\n\n        this._render.toolTipData = {\n            // 用于突出当前点的圆\n            currPoints: [],\n            pindex    : pindex,\n            leftDis,\n        };\n\n        this._datasets.forEach(( oneline, index ) => {\n            let points = this._render.pointData[index].points;\n            // pointData为了将折线图形成封闭，在开始和结束分别增加了一个辅助点\n            let curr   = points[pindex + 1];\n            let style  = oneline.style;\n\n            // 可能出现有些线比较短的情况\n            if ( curr ) {\n                let temp = {\n                    x          : curr.x,\n                    y          : curr.y,\n                    st         : 0,\n                    ed         : 2 * Math.PI,\n                    r          : style.circle.radius,\n                    fillColor  : style.lineColor,\n                    strokeColor: style.lineColor,\n                };\n\n                this._render.toolTipData.currPoints.push(temp);\n            }\n        });\n\n        let one          = this._render.toolTipData.currPoints[0];\n        let toolTipStyle = this._config.toolTip;\n\n        // 标尺\n        this._render.toolTipData.currPointsLine = {\n            start: {\n                x: one.x,\n                y: leftTop.y,\n            },\n            end: {\n                x: one.x,\n                y: leftBottom.y\n            },\n            color: toolTipStyle.lineColor,\n            width: toolTipStyle.lineWidth,\n        }\n    }\n\n    /**\n     * 计算tooltip的容器样式数据\n     */\n    calToolTipWordData(e) {\n        this._render.toolTipData.circles = [];\n\n        let wrapper     = this._render.toolTipData.wrapper;\n        let longestLine = this._render.longestLine;\n        let style       = this._config.toolTip;\n        let baseX       = wrapper.x;\n        let baseY       = wrapper.y ;\n        let words       = this._render.toolTipData.words;\n\n        let title    = {\n            x       : 0,\n            y       : baseY + style.fontSize + style.linePadding,\n            fontSize: style.fontSize,\n            color   : style.color,\n            text    : longestLine.points[this._render.toolTipData.pindex].x,\n        };\n\n        baseY += style.fontSize + style.linePadding;\n\n        words.forEach((word, index) => {\n            word.x = baseX + style.padding.left;\n\n            word.y = (  baseY\n                      + style.padding.top\n                      // 对于文字而言，是以文字左下角为圆点，所以还需要加上一个行高\n                      + style.fontSize\n                      + index * (style.fontSize + style.linePadding) );\n\n            let circle = {\n                x          : baseX + style.padding.left + style.fontSize / 2,\n                y          : word.y - style.fontSize / 2 + 1,\n                strokeColor: word.line.style.lineColor,\n                fillColor  : word.line.style.lineColor,\n                r          : style.fontSize / 2,\n            }\n\n            this._render.toolTipData.circles.push(circle);\n\n            word.x += ( style.fontSize + 5);\n        });\n\n        title.x = words[0].x;\n        words.unshift(title);\n    }\n\n    calToolTipWrapperData(e) {\n        let style       = this._config.toolTip;\n        let longestLine = this._render.longestLine;\n        let pindex      = this._render.toolTipData.pindex;\n\n        // 当前手指对应最长线的点\n        let point       = longestLine.points[pindex].x;\n        let maxWidth    = 0;\n\n        // tooltip的总宽度\n        let width       = (  style.padding.left\n                           + style.padding.right\n                           // 圆点的直径\n                           + style.fontSize\n                           // 圆点的右边距\n                           + 5  );\n\n        let height     = (  style.padding.top\n                          + style.padding.bottom\n                          // 第一行用于绘制当前X坐标的坐标值\n                          + style.fontSize\n                          + style.linePadding  );\n\n        this._render.toolTipData.words = [];\n\n        this._datasets.forEach(( oneline ) => {\n            let points = oneline.points;\n            let curr   = points[pindex];\n\n            let title = (  oneline.lineName\n                         ? oneline.lineName + ': '\n                         : ''  );\n\n            if ( curr ) {\n                let word = {\n                    text    : title + Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[\"changeUnit\"])(curr.y),\n                    fontSize: style.fontSize,\n                    color   : style.color,\n                    x       : 0,\n                    y       : 0,\n                    // 方便后续引用\n                    line    : oneline,\n                };\n\n                // 计算当前时刻最长单词的宽度\n                maxWidth = Math.max(maxWidth, this.getWordWidth(word));\n\n                // 加上每行文字的行高和行间距\n                height += ( style.fontSize + style.linePadding );\n\n                this._render.toolTipData.words.push(word);\n            }\n        });\n\n        width += maxWidth;\n\n        let data     = this._render.toolTipData;\n        let leftTop  = this._boundary.leftTop;\n        let rightTop = this._boundary.rightTop;\n\n        this._render.toolTipData.wrapper = {\n            width,\n            height,\n\n            x: (  rightTop.x - data.currPointsLine.start.x  > width\n                ? data.currPointsLine.start.x + 3\n                : data.currPointsLine.start.x - width - 3  ),\n\n            y: leftTop.y + 10,\n            fillColor: style.fillColor,\n        }\n    }\n\n    /**\n     * 计算悬浮提示数据\n     * 这里的计算其实非常繁琐而不可避免，为了提高阅读性，尽量分成三大步来计算\n     * 与initData相同的是，这里的函数调用顺序同样不能随便更改\n     */\n    calToolTipData(e) {\n        this.calToolTipPointData(e);\n        this.calToolTipWrapperData(e);\n        this.calToolTipWordData(e);\n    }\n\n    // 绘制X轴\n    drawXAxis() {\n        // 绘制Y轴文案\n        this._render.xAxisData.forEach((item) => {\n            this.drawWord(this.ctx1, item);\n        });\n\n        if ( this._config.xAxisLine.centerShow )\n            this.drawLine(this.ctx1, this._render.xCenterAxis);\n    }\n\n    // 绘制Y轴\n    drawYAxis() {\n        // 绘制Y轴文案\n        this._render.yAxisData.forEach((item) => {\n            this.drawWord(this.ctx1, item);\n        });\n\n        // 根据配置来决定是否绘制Y中心轴\n        if ( this._config.yAxis.centerShow ) {\n            this.drawLine(this.ctx1, this._render.yCenterAxis);\n        }\n    }\n\n    // 绘制Y轴横线\n    drawYAxisLine() {\n        if ( this._config.yAxisLine.show ) {\n            this._render.yAxisLines.forEach((line) => {\n                this.drawLine(this.ctx1, line);\n            });\n        }\n    }\n\n    // 绘制X轴的竖线\n    drawXAxisLine() {\n    }\n\n    /**\n     * 绘制所有的点\n     */\n    drawPoints() {\n        this._render.pointData.forEach((oneline) => {\n            this.drawLongLineWithFill(this.ctx1, oneline.points, oneline.style);\n        });\n\n        this._render.circlePoints.forEach((point) => {\n            this.drawCircle(this.ctx1, point);\n        });\n    }\n\n    drawToolTip() {\n        let data = this._render.toolTipData;\n\n        data.currPoints.forEach((point) => {\n            this.drawCircle(this.ctx2, point);\n        });\n\n        this.drawLine(this.ctx2, data.currPointsLine);\n\n        this.drawRect(this.ctx2, data.wrapper);\n\n        data.words.forEach((word) => {\n            this.drawWord(this.ctx2, word);\n        });\n\n        data.circles.forEach((circle) => {\n            this.drawCircle(this.ctx2, circle);\n        });\n    }\n\n    /**\n     * 将处理后的合法数据按照配置绘制到canvas上面\n     */\n    drawToCanvas() {\n        this.drawYAxis();\n        this.log('drawYAxis');\n\n        this.drawYAxisLine();\n        this.log('drawYAxisLine');\n\n        this.drawXAxis();\n        this.log('drawXAxis');\n\n        this.drawPoints();\n        this.log('drawPoints');\n    }\n\n    initDataSets(data) {\n        let datasets = data.datasets || [];\n\n        this._datasets = datasets.filter((item) => item.points && item.points.length);\n        if ( !this._datasets.length )\n            return;\n\n        this._datasets.forEach(( oneline ) => {\n            let defaultStyle = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[\"deepCopy\"])(this._config.lineStyle);\n            let style        = oneline.style || {};\n\n            if ( !Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[\"isPlainObject\"])(style) )\n                throw new Error('[LineChart] TypeMismatch：the style of dataset must be type of Object');\n\n            for ( let key in style ) {\n                if ( defaultStyle[key] ) {\n                    if ( Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[\"isPlainObject\"])(defaultStyle[key]) )\n                        defaultStyle[key] = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])( defaultStyle[key], style[key]);\n\n                    else\n                        defaultStyle[key] = style[key];\n                }\n            }\n\n            oneline.style = defaultStyle;\n        });\n\n        console.log(this._datasets);\n    }\n\n    /**\n     * 数据清洗和合法性判断\n     * 数据字段比较多，存在后面的函数调用依赖前面的计算结果的情况\n     * 因此不能随便调换initData里面的函数顺序\n     */\n    initData(data) {\n        // 原始调用者传入的数据\n        this.initDataSets(data);\n\n        // 为了绘制精确，首先要计算绘制的边界值，防止样式走位\n        this.calBoundaryPoint();\n\n        // 计算Y轴数据\n        this.calYAxis();\n\n        // 计算Y轴线条数据\n        this.calYAxisLines();\n\n        // 计算X轴数据\n        this.calXAxis();\n\n        // 计算X轴线条数据\n        this.calXAxisLines();\n\n        // 计算每条线的数据\n        this.calPointData();\n\n        this.log('initData');\n    }\n\n\n    /**\n     * 实际的绘制函数\n     */\n    draw(data) {\n        this._start = new Date();\n\n        this.initData(data);\n\n        this.drawToCanvas();\n\n        this.ctx1.draw();\n\n        this.log('realDraw');\n\n        if ( this._config.debug )\n            console.log(this._performance);\n\n        console.log(this._render);\n    }\n\n    /**\n     * 触摸事件处理，绘制tooltip\n     */\n    touchHandler(e) {\n        /**\n         * ctx2本身是为了性能优化存在的，如果没有ctx2，\n         * 还是要把所用东西老老实实在ctx1上面绘制一遍\n         */\n        if ( this.ctx2 === this.ctx1 ) {\n            this.drawToCanvas();\n        }\n\n        // 计算用于绘制tooltip的数据\n        this.calToolTipData(e);\n\n        // 将tooltip绘制到对应的canvas\n        this.drawToolTip();\n\n        this.ctx2.draw();\n    }\n\n    /**\n     * 处理触摸事件\n     * 因为小程序触发这个事件的频率很高，而且绘制tooltip本身也需要一点时间\n     * 这里会简单函数节流，保证触摸平滑\n     */\n    touch(e) {\n        clearTimeout(this._touchTimer);\n\n        this._touchTimer = setTimeout(() => {\n            this.touchHandler(e);\n        }, 5);\n    }\n\n    /**\n     * tooltip在触摸结束之后是否需要保留可以通过是否调用这个函数决定\n     */\n    touchEnd(e) {\n        /**\n         * ctx2本身是为了性能优化存在的，如果没有ctx2，\n         * 还是要把所用东西老老实实在ctx1上面绘制一遍\n         */\n        if ( this.ctx2 === this.ctx1 ) {\n            this.drawToCanvas();\n        }\n\n        this.ctx2.draw();\n    }\n\n    /**\n     * 尺寸变化的时候重新渲染\n     */\n    resize(width, height) {\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/*! exports provided: isType, deepCopy, isPlainObject, extend, getDataRangeAndStep, changeUnit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isType\", function() { return isType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"deepCopy\", function() { return deepCopy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPlainObject\", function() { return isPlainObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extend\", function() { return extend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDataRangeAndStep\", function() { return getDataRangeAndStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"changeUnit\", function() { return changeUnit; });\n/**\n * @author: zimyuan\n */\n\nfunction deepCopy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n\nfunction isType (type, value) {\n\tlet _type = Object\n\t\t   \t\t.prototype\n\t\t   \t\t.toString\n\t\t   \t\t.call(value)\n\t\t   \t\t.match(/\\s(\\w+)/)[1]\n\t\t   \t\t.toLowerCase();\n\n\treturn _type === type;\n}\n\nfunction isPlainObject (value) {\n\treturn ( !!value && isType('object', value) );\n}\n\nfunction extend(destination, source) {\n\tif ( !isPlainObject(destination) || !isPlainObject(source) )\n\t\tthrow 'destination and source must be type of object';\n\n\tfor ( let property in source )\n\t\tdestination[property] = source[property];\n\n\treturn destination;\n}\n\n/**\n * 数字取整逻辑\n * 在计算坐标轴的最大最小值和区间的时候，预期的效果是最大最小值都是“整数”\n * 这里根据数字的大小定义取整逻辑\n */\nfunction getRoundForNumber(number, direction) {\n    let round;\n\n    // 计算出当前数组位数减一的最小数字\n    if ( number  >= 100 )\n        round = String(number).split('')\n                              .reduce((sum, item) => sum * 10, 0.01);\n\n    // 数字介于10-100之间，逢5为整\n    else if ( number >= 10 )\n        round = 5;\n\n    else if ( number > 1 )\n        round = 1;\n\n    else\n        round = 0.1;\n\n    return round;\n}\n\nfunction roundForNumber(number, direction) {\n    let result;\n    let round = getRoundForNumber(number);\n\n    if( number === 0 )\n        return 0;\n\n    if ( direction === 'up' )\n        result = number + ( round - ( number % round ));\n\n    else if ( direction === 'down' )\n        result = number  - number % round;\n\n    return result;\n}\n\n/**\n * 给定最大值最小值和区间个数，给出优化后的最大最小值和单step值\n */\nfunction getDataRangeAndStep(max, min, step) {\n    if ( max === 0 )\n        return {\n            max     : 4,\n            min     : 0,\n            divider : 1,\n            multiple: 1\n        }\n\n    //console.log(1, max, min, step);\n    let multiple = 1;\n\n    // 每一步的值小于1的情况，先放大100倍方便计算\n    if (  ( max - min ) / step < 1 ) {\n        multiple = 100;\n        max *= multiple;\n        min *= multiple;\n    }\n\n    let originMax = max;\n    //console.log(2, max, min, step);\n\n    let divider = Math.round(( max - min ) / step);\n\n    //console.log(3, divider);\n\n    // 先将divider降低一点，后面慢慢增加逼近满意值\n    divider = roundForNumber(divider, 'down');\n    //console.log(4, divider);\n\n    // 尽量保证整个图是居中而不是贴边的\n    max = max + ( max % divider );\n    min = min - ( min % divider );\n\n    //console.log(5, max, min);\n\n    // 最小值取整，因为divider也是取整的，所以最后max也是取整的\n    min = roundForNumber(min, 'down');\n\n    //console.log(6, min);\n\n    // 逼近求理想值\n    let round = getRoundForNumber(divider);\n\n    //console.log(8, round)\n    for ( let i = 0; i < 20; i++ ) {\n        //console.log( min + divider * step , originMax, max, );\n        let temp = min + divider * step;\n        if ( temp >= max || temp - originMax >= round * 3 )\n            break;\n\n        divider += round;\n    }\n\n    return {\n        max    :( min + divider * step ) / multiple,\n        min    : min / multiple,\n        divider: divider / multiple,\n        multiple\n    };\n}\n\nfunction isNumeric(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nfunction isInt(n){\n    return Number(n) === n && n % 1 === 0;\n}\n\nfunction isFloat(n){\n    return Number(n) === n && n % 1 !== 0;\n}\n\nfunction changeUnit(value, fixed = 1) {\n    // value是非数字的情况，直接返回value\n    if ( !isNumeric(value) )\n        return value;\n\n    let number  = parseFloat(value);\n    let unit    = '';\n    let divider = 1;\n\n    // 小于1000的值，保留小数点\n    if ( isFloat(value) && number < 1000 )\n        return number.toFixed(fixed);\n\n    if ( number < 1e3 ) {\n    }\n\n    else if ( number < 1e4) {\n        unit    = 'k';\n        divider = 1e3;\n    }\n\n    else if ( number < 1e7 ) {\n        unit    = 'w';\n        divider = 1e4;\n    }\n\n    else {\n        unit    = 'kw';\n        divider = 1e7;\n    }\n\n    let temp = number / divider;\n\n    // 如果达不到保留小数的基本要求，取整\n    if ( temp - Math.floor(temp) < 0.5 * Math.pow(0.1, fixed) )\n        fixed = 0;\n\n    return temp.toFixed(fixed) + unit;\n}\n\n\n\n\n\n//# sourceURL=webpack:///./src/util.js?");

/***/ })

/******/ });